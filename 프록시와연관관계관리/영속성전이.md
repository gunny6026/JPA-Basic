# 영속성전이(CASCADE) 와 고아객체

```java
    @OneToMany(mappedBy = "parent" ,cascade = CascadeType.ALL)
    private List<Child> childList = new ArrayList<>();
```

em.persist를 일일히 하는게 귀찮다

cascade 속성을 설정 해준다.

```java
            Child child1 = new Child();
            Child child2 = new Child();
            child1.setName("이재용");
            child2.setName("이부진");


            Parent parent = new Parent();
            parent.setName("이건희");
            parent.addChild(child1);
            parent.addChild(child2);

            em.persist(parent);
//            em.persist(child1);
//            em.persist(child2);
```

persist를 parent만 해줘도 자동으로 child도 persist 된다.

## 영속성 전이 : CASCAADE - 주의!

- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다.
- 엔티티를 영속화 할 때 연관된 엔티티도 함게 영속화하는 편리함을 제공할 뿐이다.

## CASCADE의 종류

- ALL : 모두 적용
- PERSIST : 영속
- REMOVE : 삭제
- MERGE : 병합
- REFRESH : REFRESH
- DETACH : DETACH

## 고아 객체

- 고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- orphanRemoval = true
- Parent parent1 = em.find(Parent.class , id);

parent1.getChildren().remove(0);

- DELETE FROM CHILD WHERE ID=?

```java
@OneToMany(mappedBy = "parent" ,cascade = CascadeType.ALL , orphanRemoval = true)
    private List<Child> childList = new ArrayList<>();
```

orphanRemoval = true 설정을 해준 뒤에



```java
    Parent findParent = em.find(Parent.class , 13L);

          findParent.getChildList().remove(0);


            tx.commit();
```

remove(0)를 하게 되면

delete 쿼리가 나가면서 삭제가 된다.

물론 orphanRemoval 설정을 하지 않으면 delete 쿼리가 나가지 않는다.

또한 부모를 지우게 되면 자식 데이터 까지 같이 지워진다.

```java

          Parent findParent = em.find(Parent.class , 13L);

           em.remove(findParent);
```

findParent 객체에 있는 자식 까지 모두 delete 된다.

![img_3.png](img_3.png)